package slick.jdbc

import org.scalatest.{BeforeAndAfter}
import org.scalatest.funsuite.AnyFunSuite
import slick.jdbc.HanaProfile.api._
import slick.jdbc.TestSuiteData._

class TableDDLBuilderTestSuite extends AnyFunSuite with BeforeAndAfter {

  before {
  }

  test("create table statement") {
    val statements = product.schema.createStatements.toList
    assert(statements.size === 1, s"There is only ${statements.size} number of create statements generated")
    assert(statements.head === "create table \"DUMMY_SCHEMA\".\"PRODUCT\" (\"ID\" INTEGER NOT NULL PRIMARY KEY,\"NAME\" VARCHAR(20),\"ISBN_NO\" VARCHAR(254) NOT NULL)")
  }

  test("create column table with default value for fields & with auto-increment fields") {
    val statements = book_Content.schema.createStatements.toList
    assert(statements.size === 1)
    assert(statements.head === "create column table \"DUMMY_SCHEMA\".\"BOOK_CONTENT\" " +
      "(\"PAGENO\" INTEGER GENERATED BY DEFAULT AS IDENTITY(START WITH 1) NOT NULL PRIMARY KEY,\"BOOKMARK\" " +
      "INTEGER DEFAULT 0 NOT NULL,\"DESCRIPTION\" CHAR(100) NOT NULL)")
  }

  // should throw SlickException
  test("create table statement with composite primary key") {
    try {
      val statements = students.schema.createStatements.toList
      assert(statements.size === 1, s"There is only ${statements.size} number of create statements generated")
      assert(statements.head === "create table \"DUMMY_SCHEMA\".\"STUDENTS\" (\"STD\" INTEGER PRIMARY KEY,\"ROLLNO\" INTEGER PRIMARY KEY,\"NAME\" VARCHAR(254))")
    } catch {
      case e: SlickException => assert(e.getMessage == "Table STUDENTS defines multiple primary key columns")
    }
  }

  test("create table with index") {
    val statements = suppliers.schema.createStatements.toList
    statements.foreach(stmt => {
      if (stmt.contains("Idx1")) {
        assert(stmt === "create unique index \"Idx1\" on \"DUMMY_SCHEMA\".\"SUPPLIERS\" (\"ID\" desc,\"SUP_NAME\" asc)")
      }
    })
  }

  test("create table with index without sort") {
    val statements = suppliers.schema.createStatements.toList
    statements.foreach(stmt => {
      if (stmt.contains("Idx2")) {
        assert(stmt === "create index \"Idx2\" on \"DUMMY_SCHEMA\".\"SUPPLIERS\" (\"ID\",\"SUP_NAME\")")
      }
    })
  }

  test("add foreign key constraint to a table") {
    val statements = coffees.schema.createStatements.toList
    statements.foreach(stmt => {
      if (stmt.contains("fk1")) {
        assert(stmt === "alter table \"DUMMY_SCHEMA\".\"COFFEES\" add constraint \"fk1\" foreign key(\"SUP_ID\") " +
          "references \"DUMMY_SCHEMA\".\"SUPPLIERS\"(\"ID\") on update RESTRICT on delete CASCADE")
      }
    })
  }

  test("add primary key constraint to a table") {
    val statements = coffees.schema.createStatements.toList
    statements.foreach(stmt => {
      if (stmt.contains("pk1")) {
        assert(stmt === "alter table \"DUMMY_SCHEMA\".\"COFFEES\" add constraint \"pk1\" primary key(\"COF_NAME\")")
      }
    })
  }

  test("failure on multiple primary key constraints") {
    try {
      employees.schema.createStatements.toList
    } catch {
      case e: SlickException => assert(e.getMessage === "Table EMPLOYEES defines multiple primary keys (pk1, pk2)")
    }
  }

  test("drop table") {
    val statements = product.schema.dropStatements.toList
    assert(statements.size == 1)
    assert(statements.head === "drop table \"DUMMY_SCHEMA\".\"PRODUCT\"")
  }
}